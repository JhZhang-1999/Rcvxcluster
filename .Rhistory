res <- my_gd(c(2,20))
func <- function(x){
return ((10*x[1]^2+x[2]^2)/2)
}
my_gd <- function(x.init,mode='fixed',epsilon=1e-6,alpha.fixed=0.01){
res1 <- c(x.init[1])
res2 <- c(x.init[2])
x.last <- x.init
while(1){
if (mode == 'fixed'){
alpha <- alpha.fixed
}
x.next1 <- x.last[1] - alpha*5*x.last[1]
x.next2 <- x.last[2] - alpha*x.last[2]
x.next <- c(x.next1,x.next2)
res1 <- c(res1,x.next1)
res2 <- c(res2,x.next2)
if (sqrt(sum((x.last-x.next)^2)) <= epsilon){
break
}
x.last <- x.next
}
iter <- length(res1)
xval <- c(res1[iter],res2[iter])
yval <- func(xval)
plot(res1,res2,xlim=c(-20,20),ylim=c(-20,20),xlab='',ylab='')
return (list(xval=xval,yval=yval,iter=iter,res1=res1,res2=res2))
}
res <- my_gd(c(2,20))
z = matrix(0,100,100)
x1.max = max(4.5,ceiling(max(x.values[,1])))
g.2prime = function(x){
g.2prime.da2 = (12*x[1]^2)+(4*x[2])-42
g.2prime.db2 = (12*x[2]^2)+(4*x[1])-26
g.2prime.dadb = 4*(x[1]+x[2])
out = matrix(c(g.2prime.da2,g.2prime.dadb,
g.2prime.dadb,g.2prime.db2),nrow=2, byrow=TRUE)
return(out)
}
for(i in 1:itr){
x = x - solve(g.2prime(x))%*%g.prime(x)
x.values[i+1,] = x
}
g.2prime = function(x){
g.2prime.da2 = (12*x[1]^2)+(4*x[2])-42
g.2prime.db2 = (12*x[2]^2)+(4*x[1])-26
g.2prime.dadb = 4*(x[1]+x[2])
out = matrix(c(g.2prime.da2,g.2prime.dadb,
g.2prime.dadb,g.2prime.db2),nrow=2, byrow=TRUE)
return(out)
}
for(i in 1:100){
x = x - solve(g.2prime(x))%*%g.prime(x)
x.values[i+1,] = x
}
g.prime = function(x){
g.prime.da = (4*x[1]^3)+(4*x[1]*x[2])-(42*x[1])+(2*x[2]^2)-14
g.prime.db = (2*x[1]^2)-(26*x[2])-22+(4*x[1]*x[2])+(4*x[2]^3)
out = matrix(c(g.prime.da,g.prime.db),ncol=1)
return(out)
}
g.2prime = function(x){
g.2prime.da2 = (12*x[1]^2)+(4*x[2])-42
g.2prime.db2 = (12*x[2]^2)+(4*x[1])-26
g.2prime.dadb = 4*(x[1]+x[2])
out = matrix(c(g.2prime.da2,g.2prime.dadb,
g.2prime.dadb,g.2prime.db2),nrow=2, byrow=TRUE)
return(out)
}
for(i in 1:100){
x = x - solve(g.2prime(x))%*%g.prime(x)
x.values[i+1,] = x
}
g = function(x){
((x[1]^2)+x[2]-11)^2+(x[1]+(x[2]^2)-7)^2
}
x = c(-2,-2)
itr = 40
x.values = matri
g = function(x){
((x[1]^2)+x[2]-11)^2+(x[1]+(x[2]^2)-7)^2
}
x = c(-2,-2)
itr = 40
x.values = matrix(0,itr+1,2)
x.values[1,] = x
g.prime = function(x){
g.prime.da = (4*x[1]^3)+(4*x[1]*x[2])-(42*x[1])+(2*x[2]^2)-14
g.prime.db = (2*x[1]^2)-(26*x[2])-22+(4*x[1]*x[2])+(4*x[2]^3)
out = matrix(c(g.prime.da,g.prime.db),ncol=1)
return(out)
}
g.2prime = function(x){
g.2prime.da2 = (12*x[1]^2)+(4*x[2])-42
g.2prime.db2 = (12*x[2]^2)+(4*x[1])-26
g.2prime.dadb = 4*(x[1]+x[2])
out = matrix(c(g.2prime.da2,g.2prime.dadb,
g.2prime.dadb,g.2prime.db2),nrow=2, byrow=TRUE)
return(out)
}
for(i in 1:100){
x = x - solve(g.2prime(x))%*%g.prime(x)
x.values[i+1,] = x
}
g = function(x){
((x[1]^2)+x[2]-11)^2+(x[1]+(x[2]^2)-7)^2
}
x = c(-2,-2)
itr = 40
x.values = matrix(0,itr+1,2)
x.values[1,] = x
g.prime = function(x){
g.prime.da = (4*x[1]^3)+(4*x[1]*x[2])-(42*x[1])+(2*x[2]^2)-14
g.prime.db = (2*x[1]^2)-(26*x[2])-22+(4*x[1]*x[2])+(4*x[2]^3)
out = matrix(c(g.prime.da,g.prime.db),ncol=1)
return(out)
}
g.2prime = function(x){
g.2prime.da2 = (12*x[1]^2)+(4*x[2])-42
g.2prime.db2 = (12*x[2]^2)+(4*x[1])-26
g.2prime.dadb = 4*(x[1]+x[2])
out = matrix(c(g.2prime.da2,g.2prime.dadb,
g.2prime.dadb,g.2prime.db2),nrow=2, byrow=TRUE)
return(out)
}
for(i in 1:itr){
x = x - solve(g.2prime(x))%*%g.prime(x)
x.values[i+1,] = x
}
z = matrix(0,100,100)
x1.max = max(4.5,ceiling(max(x.values[,1])))
x1.min = min(-2,floor(min(x.values[,1])))
x2.max = max(3,ceiling(max(x.values[,2])))
x2.min = min(-2,floor(min(x.values[,2])))
x1 = seq(x1.min,x1.max,length=100)
x2 = seq(x2.min,x2.max,length=100)
for(i in 1:100){
for(j in 1:100){
z[i,j] = g(c(x1[i],x2[j]))
}
}
tcol <- terrain.colors(12)
contour(x1, x2, z, nlevels=20, col = tcol)
5e-6*30*24*(30*24*1e-5)^2
5*1e-6*30*24*(30*24*1e-5)^2
lam1 <- 5e-6
lam2 <- 1e-5
t <- 30*24
(lam1*t)^2
1.86624e-07+1.296e-05*3
1.86624e-07+(1.296e-05)*3
(lam1*t)^2*(lam2*t)^2
(lam1*t)^3*(lam2*t)^2
(lam1*t)^3
3.906662e-05-6.718464e-10*2-3*4.6656e-8-2.418647e-12
lam2*t
(lam2*t)^2
lam1*t+(1-lam2*t)*(lam2*t)^2
p3l <- lam1*t+(1-lam2*t)*(lam2*t)^2
lam1*t
lam1*t+(1-lam1*t)*p3l
(lam1*t)^2
p2l <- lam1*t+(1-lam1*t)*p3l
p2r <- (lam1*t)^2
lam1*t*p2l + (1-lam1*t)*p2r
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(ggpubr)
SAlr <- read.table('SA_ins2.txt',sep=',')
pp4 <- ggplot(data=NULL,aes(seq(1,length(SAlr)),SAlr)) +
geom_line(aes(seq(1,length(SAlr)),SAlr)) +
theme_classic() + xlab('Epoch') + ylab('Space Utilization') +
ggtitle('Learning Curve of GA Tree')
pp4
SALR
SAlr
SAlr <- read.table('SA_ins2.txt',sep=',')
colnames(SAlr) <- c('FIT')
pp4 <- ggplot(data=NULL,aes(seq(1,length(SAlr)),SAlr)) +
geom_line(aes(seq(1,length(SAlr)),SAlr$FIT)) +
theme_classic() + xlab('Epoch') + ylab('Space Utilization') +
ggtitle('Learning Curve of SA')
pp4
SAlr
SAlr <- read.table('SA_ins2.txt',sep=',')
colnames(SAlr) <- c('FIT')
pp4 <- ggplot(data=NULL,aes(seq(1,15),SAlr)) +
geom_line(aes(seq(1,15),SAlr$FIT)) +
theme_classic() + xlab('Epoch') + ylab('Space Utilization') +
ggtitle('Learning Curve of SA')
pp4
SAlr
pcom<-ggarrange(pp1,pp2,pp3,pp4,nrow=2, ncol=2)
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(ggpubr)
utilization <- read.csv('Results_utilization.csv',header=T,sep=',')
utilization <- utilization[,2:6]
utilization
p1 <- ggplot(data=utilization[1:5,],aes(seq(1,10),TertiaryTree)) +
geom_boxplot(aes('Tertiary Tree',TertiaryTree)) +
geom_boxplot(aes('Original GA',OriginalGA)) +
geom_boxplot(aes('GA Tree',GATree)) +
geom_boxplot(aes('SA',SA)) +
geom_boxplot(aes('JADE',JADE)) +
xlab("") + ylim(c(0.35,1)) +
theme_classic() + ylab('Space Utilization') + ggtitle("Boxplot for Standard Instance")
p1
p2 <- ggplot(data=utilization[6:10,],aes(seq(1,10),TertiaryTree)) +
geom_boxplot(aes('Tertiary Tree',TertiaryTree)) +
geom_boxplot(aes('Original GA',OriginalGA)) +
geom_boxplot(aes('GA Tree',GATree)) +
geom_boxplot(aes('SA',SA)) +
geom_boxplot(aes('JADE',JADE)) +
xlab("") + ylim(c(0.35,1)) +
theme_classic() + ylab('Space Utilization') + ggtitle("Boxplot for Hetero Instance")
p2
value <- read.csv('Results_value.csv',header=T,sep=',')
value <- value[,2:6]
value
p3 <- ggplot(data=value[1:5,],aes(seq(1,10),TertiaryTree)) +
geom_boxplot(aes('Tertiary Tree',TertiaryTree)) +
geom_boxplot(aes('Original GA',OriginalGA)) +
geom_boxplot(aes('GA Tree',GATree)) +
geom_boxplot(aes('SA',SA)) +
geom_boxplot(aes('JADE',JADE)) +
xlab("") + ylim(c(2e+05,1e+06)) +
theme_classic() + ylab('Total Value') + ggtitle("Boxplot for Standard Instance")
p3
p4 <- ggplot(data=value[6:10,],aes(seq(1,10),TertiaryTree)) +
geom_boxplot(aes('Tertiary Tree',TertiaryTree)) +
geom_boxplot(aes('Original GA',OriginalGA)) +
geom_boxplot(aes('GA Tree',GATree)) +
geom_boxplot(aes('SA',SA)) +
geom_boxplot(aes('JADE',JADE)) +
xlab("") + ylim(c(2e+05,1e+06)) +
theme_classic() + ylab('Total Value') + ggtitle("Boxplot for Hetero Instance")
p4
pcom<-ggarrange(p1,p2,p3,p4,nrow=2, ncol=2)
pcom
ggsave('new3.png',width=12,height=10)
oriGAlr <- read.table('oriGAhomo_out.txt',sep=',')
oriGAlr <- oriGAlr[,1:4]
colnames(oriGAlr) <- c('Instance','AVG','MAX','MIN')
oriGAlr
pp1 <- ggplot(data=NULL,aes(seq(1,50),oriGAlr[oriGAlr$Instance==2,])) +
geom_line(aes(seq(1,50),oriGAlr[oriGAlr$Instance==2,]$MIN)) +
geom_line(aes(seq(1,50),oriGAlr[oriGAlr$Instance==2,]$MAX)) +
geom_line(aes(seq(1,50),oriGAlr[oriGAlr$Instance==2,]$AVG)) +
theme_classic() + xlab('Epoch') + ylab('Space Utilization') +
ggtitle('Learning Curve of Original GA')
pp1
GATlr <- read.table('final_ins2.txt',sep=',')
GATlr <- GATlr[,2:4]
colnames(GATlr) <- c('AVG','MAX','MIN')
pp2 <- ggplot(data=NULL,aes(seq(1,50),GATlr)) +
geom_line(aes(seq(1,50),GATlr$MIN)) +
geom_line(aes(seq(1,50),GATlr$MAX)) +
geom_line(aes(seq(1,50),GATlr$AVG)) +
theme_classic() + xlab('Epoch') + ylab('Space Utilization') +
ggtitle('Learning Curve of GA Tree')
pp2
JADElr <- read.csv('result_instance2_learning.csv',sep=',',header=T)
JADElr <- JADElr[,2:4]
colnames(JADElr) <- c('AVG','MAX','MIN')
pp3 <- ggplot(data=NULL,aes(seq(1,50),JADElr)) +
geom_line(aes(seq(1,30),JADElr$MIN)) +
geom_line(aes(seq(1,30),JADElr$MAX)) +
geom_line(aes(seq(1,30),JADElr$AVG)) +
theme_classic() + xlab('Epoch') + ylab('Space Utilization') +
ggtitle('Learning Curve of JADE')
pp3
SAlr <- read.table('SA_ins2.txt',sep=',')
colnames(SAlr) <- c('FIT')
pp4 <- ggplot(data=NULL,aes(seq(1,15),SAlr)) +
geom_line(aes(seq(1,15),SAlr$FIT)) +
theme_classic() + xlab('Epoch') + ylab('Space Utilization') +
ggtitle('Learning Curve of SA')
pp4
pcom<-ggarrange(pp1,pp2,pp3,pp4,nrow=2, ncol=2)
pcom
ggsave('lr.png',width=12,height=10)
oriGAlr <- read.table('oriGAhomo_out.txt',sep=',')
oriGAlr <- oriGAlr[,1:4]
colnames(oriGAlr) <- c('Instance','AVG','MAX','MIN')
oriGAlr
pp1 <- ggplot(data=NULL,aes(seq(1,50),oriGAlr[oriGAlr$Instance==2,])) +
geom_line(aes(seq(1,50),oriGAlr[oriGAlr$Instance==2,]$MIN)) +
geom_line(aes(seq(1,50),oriGAlr[oriGAlr$Instance==2,]$MAX)) +
geom_line(aes(seq(1,50),oriGAlr[oriGAlr$Instance==2,]$AVG)) +
theme_classic() + xlab('Epoch') + ylab('Space Utilization') +
ggtitle('Learning Curve of Original GA') + ylim(0.3,1)
pp1
GATlr <- read.table('final_ins2.txt',sep=',')
GATlr <- GATlr[,2:4]
colnames(GATlr) <- c('AVG','MAX','MIN')
pp2 <- ggplot(data=NULL,aes(seq(1,50),GATlr)) +
geom_line(aes(seq(1,50),GATlr$MIN)) +
geom_line(aes(seq(1,50),GATlr$MAX)) +
geom_line(aes(seq(1,50),GATlr$AVG)) +
theme_classic() + xlab('Epoch') + ylab('Space Utilization') +
ggtitle('Learning Curve of GA Tree') + ylim(0.3,1)
pp2
JADElr <- read.csv('result_instance2_learning.csv',sep=',',header=T)
JADElr <- JADElr[,2:4]
colnames(JADElr) <- c('AVG','MAX','MIN')
pp3 <- ggplot(data=NULL,aes(seq(1,50),JADElr)) +
geom_line(aes(seq(1,30),JADElr$MIN)) +
geom_line(aes(seq(1,30),JADElr$MAX)) +
geom_line(aes(seq(1,30),JADElr$AVG)) +
theme_classic() + xlab('Epoch') + ylab('Space Utilization') +
ggtitle('Learning Curve of JADE') + ylim(0.3,1)
pp3
SAlr <- read.table('SA_ins2.txt',sep=',')
colnames(SAlr) <- c('FIT')
pp4 <- ggplot(data=NULL,aes(seq(1,15),SAlr)) +
geom_line(aes(seq(1,15),SAlr$FIT)) +
theme_classic() + xlab('Epoch') + ylab('Space Utilization') +
ggtitle('Learning Curve of SA') + ylim(0.3,1)
pp4
pcom<-ggarrange(pp1,pp2,pp3,pp4,nrow=2, ncol=2)
pcom
ggsave('lr2.png',width=12,height=10)
sqrt(2*400*240000/0.2/1)
sqrt(2*400*240000/0.2/.98)
400*240000/31298.43+.98*240000+.2*.98*31298.43/2
sqrt(2*400*240000/0.2/.96)
400*240000/20000+.98*240000+.2*.98*20000/2
400*240000/40000+.98*240000+.2*.98*40000/2
31298.43/
2
sqrt(2*400*240000/0.2/.96)
400*240000/31622.78+.96*240000+.2*.96*31622.78/2
sqrt(2*400*240000/0.2/.96)/2
x <- c(1,2)
y <- c(3,4)
res <- c(x,y)
res
20000+.98*20000
0.02*20000
39600-.96*40000
sqrt(2*400*240000/.2)
sqrt(2*800*240000/.2/.98)
sqrt(2*1600*240000/.2/.96)
0.96*240000+1200*240000/63245.55+400*240000/63245.55+0.2*0.96/2*63245.55+.2*600
sqrt(2*1600*240000/.2/.96)/2
library(devtools)
devtools::install_github('SugiharaLab/rEDM')
install.packages("D:/Application/CODING/R/rEDM_1.7.0.tar.gz", repos = NULL, type = "source")
download.file('https://cran.r-project.org/src/contrib/rEDM_1.7.0.tar.gz',
f <- tempfile())
unzip(f, exdir=tempdir())
download.file('https://cran.r-project.org/bin/windows/contrib/4.0/rEDM_1.7.0.zip',
f <- tempfile())
unzip(f, exdir=tempdir())
load(file.path(tempdir(), '.RData'))
install.packages('CausalImpact')
knitr::opts_chunk$set(echo = TRUE)
library(CausalImpact)
set.seed(1)
x1 <- 100 + arima.sim(model = list(ar = 0.999), n = 100)
y <- 1.2 * x1 + rnorm(100)
y[71:100] <- y[71:100] + 10
data <- cbind(y, x1)
matplot(data, type = "l")
pre.period <- c(1, 70)
post.period <- c(71, 100)
impact <- CausalImpact(data,pre.period,post.period)
plot(impact)
0.08*3/8+0.16*5/8
0.13+0.05*1/3
(0.13+0.05*1/3)*60
50*.16
.14+(.14-.095)*45/55
9.5%
0.095*0.6*0.45+0.1768*0.55
0.06*0.2+0.12*0.8
ratio <- seq(4,0.1,0.01)
ratio <- seq(4,0.1,-0.01)
ratio <- seq(0.25,4,0.01)
re <- 0.108+0.048*ratios
re <- 0.108+0.048*ratio
plot(ratio,re)
plot(ratio,re,type='l')
points(ratio,rep(0.108,length(ratio)),type='l')
points(ratio,rep(0.108,length(ratio)),type='l')
plot(ratio,re,type='l')
re
ratio
ratio <- seq(0,4,0.01)
re <- 0.108+0.048*ratios
re <- 0.108+0.048*ratio
plot(ratio,re)
plot(ratio,re,type='l')
points(ratio,0.108)
points(ratio,rep(0.108,length(ratio)),type='l')
plot(ratio,re,type='l',ylim=c(0.05,0.35))
points(ratio,rep(0.108,length(ratio)),type='l')
plot(ratio,re,type='l',ylim=c(0.05,0.35))
plot(ratio,re,type='l',ylim=c(0.05,0.35),col='red')
points(ratio,rep(0.108,length(ratio)),type='l',col='blue')
f <- function(x1,x2,x3){((1-0.2^x1)*(1-0.25^x2)*(1-0.3^x3))}
g <- function(x1,x2,x3){(4.5*x1+1.7*x2+2.3*x3)}
f(2.96104,4.02874,4.27237)
g(2.96104,4.02874,4.27237)
f(2,5.024,5.41705)
f(3,3.98837,4.22599)
f(3,3,4.95652)
f(3,4,4.21739)
g(3,4,4.21739)
f(3,4,4)
f(3,4,5)
g(3,4,4)
g(3,4,5)
6*3+4*9
6*3+5*4+3*4
1-exp(-0.5)/5/10^4
(1-exp(-0.5)/5/10^4)/0.5
(1-exp(-.5))/.5
(1-exp(-.5))/.5*0.98
(1-exp(-.5))/(5*10^(-4))+0.98*(1-exp(-10))/5/10^(-4)
2746.85/1200
(1-exp(-.5))/(5*10^(-4))+0.98*(1-exp(-.1))/5/10^(-4)
973.4573/1200
0.98*exp(-5*10^(-4)*(200))
library(devtools)
devtools::install_github('JiahuiZhang-1999/Rcvxcluster')
devtools::install_github('JhZhang-1999/Rcvxcluster')
remove.packages('Rcvxcluster')
devtools::install_github('JhZhang-1999/Rcvxcluster')
library(Rcvxclustr)
library(devtools)
devtools::install_github('JhZhang-1999/Rcvxcluster')
setwd('D:\\LIFE\\WORK\\4-University\\Research\\Rcvxcluster_cont\\Rcvxcluster')
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::install_github('JhZhang-1999/Rcvxcluster')
library(Rcvxcluster)
help(Huber_ADMM)
help(Rcvxcluster)
library(MASS)
library(clues)
library(cvxclustr)
set.seed(1234) # maybe should be a variable later
N=25 #?
p=20 #?
# mvrnorm: multivariate normal distribution
mu1 <- mvrnorm(mu=rep(0,p),Sigma = diag(1,p))
X1 <- mvrnorm(N,mu=mu1,Sigma=diag(1,p))
mu2 <- mvrnorm(mu=rep(5,p),Sigma = diag(1,p))
X2 <- mvrnorm(N,mu=mu2,Sigma=diag(1,p))
X <- rbind(X1, X2) # dim(X) = 2*N p
n = dim(X)[1] # why not n=2*N directly?
outliers <- sample(c(runif(n=5,min=20,max=50),runif(n=5,min=-50,max=-20)))
X[sample(1:(n*p),10)] <- outliers # put outliers randomly in X
### Weights
# create wt using 2.5
distance <- matrix(0,nrow=n,ncol=n)
for(i in seq(from=1,to=n-1,by=1)){
for(j in seq(from=i+1,to=n, by=1)){
distance[i,j]<-norm(X[i,] - X[j,],type = "2")
distance[j,i]<-norm(X[i,] - X[j,],type = "2")
}
}
delta <- 15 # variable later?
zeta <- 0.1 # variable later?
wt <- matrix(0,n,n) # n*n matrix, all elements=0
for(i in 1:n){
for(j in 1:n){
if(distance[i,j]==0){
wt[i,j]=0
}
else if(distance[i,j]<delta){
wt[i,j]=exp(-0.5*zeta*distance[i,j]) # why 0.5?
}
else{wt[i,j]=exp(-0.5*zeta*delta)} # why 0.5?
}
}
library(gdata)
wt1.vec <- lowerTriangle(wt) # the lowerTri part of wt, as a vector(bycol)
H <- Huber_ADMM(X,lam=0.7,wt=wt.vec) # using Huber function
H <- Huber_ADMM(X,lam=0.7,wt=wt1.vec) # using Huber function
H$V
dim(H$V)
dim(X)
A <- create_adjacency(t(H$V),wt.vec,n,method="admm") # QUESTION HERE
A
dim(A)
dim(H$V)
di(X)
dim(X)
V[1:10,1:10]
V
H$V
H$V[1:10,1:1]
H$V[1:10,1:110]
H$V[1:10,1:10]
H$V[50:80,50:80]
dim(H$V)
H$V[50:80,]
help("create_adjacency")
dim(H$V)
help("cvxclustr-package")
?Huber_ADMM
help(Huber_ADMM)
help("weight_delta")
wt
dim(wt)
